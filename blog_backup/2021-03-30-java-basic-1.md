---
title: Java基础笔记：面向对象
author: MuMu
date: 2021-03-30 19:32:00
categories: [Java]
tags: [Java]
---

### 封装的实现

1. 修改属性的可见性(private)
2. 创建getter/setter方法(public)
3. 在g/s方法中加入属性控制语句，对属性值的合法性进行判断。

### static关键字

静态成员的生命周期：类加载时产生，类销毁时消亡。

+ 普通代码块：先出现先执行
+ 构造代码块：**创建对象**时调用，优先于构造方法执行
+ 静态代码块：**类加载**时调用，优先于构造代码块执行

> *无论实例化多少个对象，静态代码块始终只执行一次，而构造代码块每次实例化都会执行一次*
>
> 执行顺序为：静态代码块→ 构造代码块→构造方法

### 继承

通过**extends**关键字实现。

继承会继承父类所有的属性和方法，并不能选择只继承某一个特定的属性和方法。

只能继承一个父类。

子类可以访问父类**非私有**成员。

父类不能访问子类特有成员。

### 重载与重写

方法重载：

1. 同一个类中
2. 方法名相同，参数列表**不同**（参数顺序，个数，类型），与参数名无关
3. 方法返回值，访问修饰符**任意**

方法重写：

1. 在有继承关系的子类中定义

2. 方法名相同，参数列表**完全相同**（参数顺序，个数，类型），与参数名无关

3. 当方法返回值是void或基本数据类型时，必须完全相同

   当返回值是引用类型时，可以是父类或其子类

4. 访问修饰符，子类的访问范围需要大于等于父类的访问范围。

*当子类重写父类的方法之后，子类对象调用的是重写后的方法。*

父类的构造方法不允许被继承、重写，但是会影响子类的实例化过程。

### 访问修饰符

* **private**：只允许在本类中进行访问
* **public**：允许在任意位置访问
* **protected**：允许在当前类，同包子类/非子类，跨包子类
* 默认：允许在当前类，同包子类/非子类

### 继承的初始化顺序

父类静态成员→子类静态成员→父类对象构造→子类对象构造

*访问修饰符不影响成员加载顺序，与书写位置有关。*

当在子类的构造方法中没有显式标注时，默认调用父类的无参构方法。

在子类中使用==super==关键字可以调用父类派生给子类的属性和方法，以及指定的允许被访问的父类构造方法（此时需要放在第一行）

### Object类

Object类是所有类的父类

### final关键字

+ 修饰类：表示该类没有子类，不允许被继承

+ 修饰方法：表示该方法不允许被子类重写，可以被子类继承使用

+ 修饰方法内局部变量 ：具体使用之前赋值即可，一旦被赋值不允许被修改
+ 修饰类中成员变量：只能以 a.定义直接初始化 b.构造方法 c.构造代码块 三种方式进行赋值

+ 修饰引用数据类型：实例化之后不允许修改引用地址，但是可以可以修改对象属性值

+ 不能修饰构造方法

### 单例模式

*使类的一个对象成为系统中的唯一实例*

使用场景：

1. 创建对象时占用资源过多
2. 对系统内资源要求同一读写，如读写配置信息
3. 当多个实例存在时可能引起程序逻辑错误，如号码生成器

实现：

1. 只提供私有的构造方法
2. 含有一个该类的静态私有对象
3. 提供一个静态的公有方法用于创建、获取静态私有对象

**饿汉式**：创建对象实例的时候直接初始化（空间换时间）

```java
public class Singleton {
    //1. 创建私有构造
    private Singleton() {
    }
    //2. 创建私有静态实例
    private static Singleton instance = new Singleton();

    //3. 创建公有静态方法返回静态实例对象
    public static Singleton getInstance() {
        return instance;
    }
}
```

**懒汉式**：创建对象实例时并不直接初始化，直到第一次调用get()方法才完成初始化操作（时间换空间）

```java
public class Singleton {
    //1. 创建私有构造
    private Singleton() {

    }
    //2. 创建私有静态对象但不直接初始化
    private static Singleton instance = null;

    //3. 创建公有静态方法返回静态实例对象
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

饿汉式线程安全，懒汉式存在线程风险

单例模式的优点：

+ 内存中只有一个对象，节省内存空间
+ 避免频繁创建销毁对象，提高性能
+ 避免对共享资源的多重占用

单例模式的缺点：

+ 扩展比较困难
+ 实例化后的对象长期不利用会被系统回收

### 多态

*程序运行时决定调用哪个方法*

必要条件：

+ 满足继承关系
+ 父类引用指向子类对象

```java
Animal one = new Animal();

//向上转型：把一个子类对象转型为父类对象（小向大转）
//可以调用子类重写父类的方法以及父类派生的方法，无法调用子类独有的方法。
//注意：父类中的静态方法无法被子类重写，向上转型之后只能调用父类原有的静态方法
//可以向下转型之后再调用子类的静态方法
Animal two = new Cat();
Animal three = new Dog();

//向下转型(强制类型转换)
//必须满足转型条件instanceof才能进行强转
Cat temp = (Cat)two;

public void feed(Animal obj) {
    obj.eat();
    if(obj instanceof Cat) {
        Cat temp = (Cat)obj;
        temp.playball();
    } else if(obj instanceof Dog) {
        Dog temp = (Dog)obj
        temp.sleep();
    }
}

//多态的应用
//同一个操作行为,针对不同的参数，返回不同的实例对象，完成不同的操作结果
public Animal raise(boolean isManyTime) {
    if(isManyTime) {
        return new Dog();
    } else {
        return new Cat();
    }
}

```

#### 1. abstract关键字

抽象类：只能被继承，不允许直接实例化，可以通过向上转型指向子类实例完成实例化

抽象方法：没有方法体，必须在子类中重写父类的抽象方法，否则子类也为抽象类

抽象类中可以没有抽象方法，包含抽象方法的类一定是抽象类

abstract 不能与 static / final / private 并存

#### 2. 接口

 *定义了某一批类所需要遵守的规范*

*不关心类的内部数据与实现细节，只规定这些类里必须提供某些方法*

```java
//接口访问修饰符：public / 默认
public interface INet {
    /*
	 *	接口中的抽象方法可以不写abstract关键字
	 *	当类实现接口时，需要实现接口中所有的抽象方法，负责该类为抽象类
 	 */
    void photo();

    //default:可以带方法体
    //可以在实现类中重写，通过接口的引用调用
    default void connection() {
        System.out.println(" = = =");
    }

    //static:静态方法，可以带方法体
    //不可以在实现类中重写，通过接口名调用
    static void stop() {
        System.out.println(" = = =");
    }

    //接口中可以包含常量，默认为public static final
    int TEMP = 20;
}
```

一个类可以继承唯一父类的同时实现多个接口。

接口中**重名方法**的处理方案：

​		多个接口中存在同名方法时，实现类中需要重写属于自己的方法。如果继承自父类，则默认会调	用父类的重名方法。

接口中**重名常量**的处理方案：

​		指定访问的常量属于哪个接口。

​		若继承的父类中也有该同名常量，则需在子类中定义其独有的同名成员。

接口的继承：

​		接口也可以实现继承，并且可以一次继承多个父接口。

​		若多个父接口中有同名默认方法，则子接口需要创建自己的同名方法。

#### 3. 内部类

*内部类隐藏在外部类之中，更好地实现了信息隐藏*

1. 成员内部类（普通内部类）

   + 内部类在外部使用时，无法直接实例化，==需要借由外部类==信息才能实例化

   + 内部类的访问修饰符可以任意，但是访问范围会受影响

   + 内部类可以直接访问外部类的成员，如果出现同名属性，优先访问内部类中定义的

     可以使用 外部类.this.成员 的方式来访问外部类中的同名信息

   + 外部类访问内部类信息，需要通过内部类实例，无法直接访问

   获取内部类对象实例的几种方式：

   ```java
   public class PersonTest {
       public static void main(String[] args) {
           Person matt = new Person();
           matt.age = 25;

           //方式1：new 外部类.new 内部类
           Person.Heart myHeart = new Person().new Heart();

           //方式2：外部类对象.new 内部类
           myHeart = matt.new Heart();

           //方式3：外部类对象.获取方法
           myHeart = matt.getHeart();
       }
   }
   ```

2. 静态内部类

   + 可以**不依赖于外部类**对象，直接创建

   + 静态内部类中，只能直接访问外部类的静态成员。如果需要调用非静态成员，可以通过对象实例

   + 可以通过 外部类.内部类.静态成员 的方式，访问内部类中的静态成员

   + 内部类属性与外部类同名时，默认直接调用内部类成员；

     如果需要访问外部类中的静态属性，则可以通过 外部类.属性 的方式

     如果需要访问外部类中的非静态属性，则可以通过 new 外部类().属性 的方式

3. 方法内部类

   + 定义在方法内部，作用范围也在方法内
   + class前面不能加public / private / protected / static
   + 类中不能包含静态成员
   + 类中可以包含final / abstract 修饰的成员

4. 匿名内部类

   *将类的定义与创建放到一起完成*

   + 没有类型名、实例对象名
   + 无法使用 private / public /  protected / abstract / static 修饰符
   + 无法编写构造方法，可以通过构造代码块实现
   + 不能出现静态成员
   + 可以实现接口也可以继承父类，但是不能兼得

   ```java
   test.getRead(new Person() {
       {
           //构造代码块
       }
       public void read() {
           System.out.println("Read");
       }
   });
   ```

   使用场景：

   ​+ 只用到类的一个实例

   ​+ 类在定义之后马上用到
