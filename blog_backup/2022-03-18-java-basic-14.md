---
title: Synchronized 锁升级流程
author: MuMu
categories: [Java]
---

Java 对象是存放在堆内存之中的，其由三部分组成：**对象头**、**实例变量**、**填充字节**。

+ 对象头：主要由标记字段、类型指针组成
+ 实例变量：主要存放类的属性信息，包括其父类的属性信息
+ 填充数据：仅仅为了字节对齐

在早期版本的 Java 中，synchronized 属于重量级锁，因为操作系统实现的线程切换需要从用户态转到核心态，状态之间的转换需要较大的时间成本。

`synchronized` 锁有四种状态：无锁，偏向锁，轻量级锁，重量级锁。

这几个状态会随着竞争状态逐渐升级，**锁可以升级但不能降级，但是偏向锁状态可以被重置为无锁状态**。

**为什么需要偏向锁：**

研究发现，大多数时候常常是一个线程多次获得同一个锁，为了减低锁获取的代价引入了偏向锁。

**偏向锁的升级流程：**

+ 当线程1访问代码块获取锁对象时，会在 Java 对象头和栈帧中记录偏向锁的 threadID ，而偏向锁不会主动释放锁。
+ 当又有线程来获取这个锁对象时，会比较当前线程的 threadID 与 Java 对象头中存放的 threadID是否一致。
+ 如果一致（还是线程1获取锁）：则无需使用 CAS 来加锁解锁。
+ 如果不一致（其他线程来获取锁）：则会检查线程1是否存活。
  + 如果没有存活：将偏向锁重置为无锁状态，其他线程可以竞争修改为偏向锁
  + 如果存活：查找线程1的栈帧信息，看其是否需要继续持有锁。需要继续持有：撤销偏向锁，将锁升级为轻量级锁。不需要继续持有：将锁对象重置为无锁状态。

**为什么需要轻量级锁：**

轻量级锁考虑的是竞争锁的线程不多，并且线程持有锁的时间不长的情况。因为阻塞线程需要 CPU 从用户态转换到内核态，代价很大。所以要避免刚阻塞不久这个锁就被释放的情况，不如不阻塞这个线程，让它自旋等待锁的释放。

**轻量级锁的升级流程：**

+ 线程1获取轻量级锁是，会把锁对象的对象头中的**标记字段**复制一份到线程1的**栈帧**中创建的用于存储锁记录的空间中，然后使用 CAS 将锁的对象头中的内容替换为线程1栈帧中存储锁记录的地址。
+ 线程1复制对象头时，线程2获取锁，将锁的对象头复制到线程2的记录空间中， CAS 时，会发现锁的对象头已经被替换，此时线程2 CAS 失败，尝试使用自旋锁来等待线程1释放锁。（自旋锁简单来说就是让线程2在循环中不断CAS）
+ 如果线程2的**自旋次数达到限制**后，线程1还没有释放锁。或者线程2在自旋等待时，又有线程3来竞争锁对象。此时，轻量级锁会膨胀为重量级锁。（**重量级锁会把除了拥有锁的线程都阻塞，防止CPU空转**）

![在这里插入图片描述](https://blog.caowei.xyz/blog/20200209103510228.png)